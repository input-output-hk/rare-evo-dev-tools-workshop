# Using cardano-testnet in cardano-node CI

The `cardano-node` is a composite system, integrating several core components such as Ouroboros-Consensus, Ouroboros-Network, Cardano-Ledger, and Plutus. While each component undergoes intensive, isolated testing in its own CI environment, the integration of new versions requires ensuring all parts function correctly as a cohesive whole.

To validate this integration, `cardano-testnet` plays a pivotal role in the Continuous Integration (CI) pipeline for every Pull Request (PR) submitted to the `cardano-node` repository. Certain tests can only be executed on a live network. For these, the CI process automatically uses `cardano-testnet` to launch local testnet clusters on the runner machine, allowing a critical suite of on-chain tests to be executed.

This procedure acts as a fundamental quality gate. A PR can only be merged into the main codebase if all checks, including the tests run against the `cardano-testnet` clusters, pass successfully. This process is further complemented by a dedicated test engineering team at IOG, which runs more exhaustive end-to-end tests on release candidates and as part of nightly builds, catching potential issues at the earliest possible stage.

For example, run the following command in the cardano-node repository to execute all cardano-testnet tests:

```shell
 DISABLE_RETRIES=1 cabal test cardano-testnet-test
```

Let's zoom in to the TreasuryWithrawal test, you can find it in https://github.com/IntersectMBO/cardano-node/blob/master/cardano-testnet/test/cardano-testnet-test/Cardano/Testnet/Test/Gov/TreasuryWithdrawal.hs we just added a few more comments below to help understand what is going on during the test. 


```haskell
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE DerivingVia #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE NumericUnderscores #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeApplications #-}

module Cardano.Testnet.Test.Gov.TreasuryWithdrawal
  ( hprop_ledger_events_treasury_withdrawal
  ) where

import           Cardano.Api
import           Cardano.Api.Ledger (Coin, Credential, EpochInterval (EpochInterval),
                   KeyRole (Staking))

import qualified Cardano.Ledger.BaseTypes as L
import qualified Cardano.Ledger.Coin as L
import qualified Cardano.Ledger.Conway.Governance as L
import qualified Cardano.Ledger.Shelley.LedgerState as L
import           Cardano.Testnet

import           Prelude

import           Control.Monad
import           Control.Monad.State.Class
import           Data.Bifunctor (Bifunctor (..))
import           Data.Default.Class
import           Data.Map (Map)
import qualified Data.Map.Strict as M
import qualified Data.Text as Text
import           GHC.Stack
import           Lens.Micro
import           System.Directory (makeAbsolute)
import           System.FilePath ((</>))

import           Test.Cardano.CLI.Hash (serveFilesWhile)
import           Testnet.Components.Query
import           Testnet.Defaults
import           Testnet.Process.Cli.Keys (cliStakeAddressKeyGen)
import           Testnet.Process.Cli.SPO (createStakeKeyRegistrationCertificate)
import           Testnet.Process.Cli.Transaction (retrieveTransactionId)
import           Testnet.Process.Run (addEnvVarsToConfig, execCli', mkExecConfig)
import           Testnet.Property.Util (integrationRetryWorkspace)
import           Testnet.Start.Types
import           Testnet.Types

import           Hedgehog
import qualified Hedgehog.Extras as H

-- | This test verifies the end-to-end process of a treasury withdrawal governance action
-- in the Conway era. It ensures that a proposal to withdraw funds from the Cardano treasury
-- can be submitted, voted on by DReps, ratified, and that the funds are correctly paid out
-- to the designated stake address upon enactment.
hprop_ledger_events_treasury_withdrawal:: Property
hprop_ledger_events_treasury_withdrawal = integrationRetryWorkspace 2 "treasury-withdrawal" $ \tempAbsBasePath' -> H.runWithDefaultWatchdog_ $ do
  -- ## 1. Test Setup and Initialization ##
  -- This initial section sets up the entire testing environment.

  -- Create a temporary, isolated directory for all test files to ensure a clean slate for every run.
  conf@Conf { tempAbsPath } <- H.noteShowM $ mkConf tempAbsBasePath'
  let tempAbsPath' = unTmpAbsPath tempAbsPath
      tempBaseAbsPath = makeTmpBaseAbsPath tempAbsPath

  work <- H.createDirectoryIfMissing $ tempAbsPath' </> "work"

  -- Explicitly define that the test will run in the Conway era.
  let ceo = ConwayEraOnwardsConway
      sbe = convert ceo
      era = toCardanoEra sbe
      eraName = eraToString era

      -- Configure 'cardano-testnet' with options for a "fast" testnet (e.g., short epochs of 200 slots)
      -- to ensure the test completes in a reasonable amount of time.
      fastTestnetOptions = def { cardanoNodeEra = AnyShelleyBasedEra sbe }
      shelleyOptions = def { genesisEpochLength = 200
                           , genesisActiveSlotsCoeff = 0.3
                           }

  -- This is where 'cardano-testnet' is invoked to spin up a new, local Cardano testnet from scratch.
  -- It returns a 'TestnetRuntime' record containing all necessary information to interact with the
  -- new network (sockets, wallets, config files).
  TestnetRuntime
    { testnetMagic
    , testnetNodes
    , wallets=wallet0:wallet1:_
    , configurationFile
    }
    <- cardanoTestnetDefault fastTestnetOptions shelleyOptions conf

  -- Prepare an 'execConfig' which is a helper configuration used to run 'cardano-cli' commands
  -- without having to repeatedly specify the socket path and network magic.
  node@TestnetNode{nodeSprocket} <- H.headM testnetNodes
  poolSprocket1 <- H.noteShow nodeSprocket
  execConfig <- mkExecConfig tempBaseAbsPath poolSprocket1 testnetMagic
  let socketPath = nodeSocketPath node

  epochStateView <- getEpochStateView configurationFile socketPath

  H.note_ $ "Sprocket: " <> show poolSprocket1
  H.note_ $ "Abs path: " <> tempAbsBasePath'
  H.note_ $ "Socketpath: " <> unFile socketPath
  H.note_ $ "Foldblocks config file: " <> unFile configurationFile

  gov <- H.createDirectoryIfMissing $ work </> "governance"

  -- A governance action requires "off-chain" metadata, referenced by an "anchor" URL and hash.
  let proposalAnchorDataIpfsHash = "QmexFJuEn5RtnHEqpxDcqrazdHPzAwe7zs2RxHLfMH5gBz"
  proposalAnchorFile <- H.noteM $ liftIO $ makeAbsolute $ "test" </> "cardano-testnet-test" </> "files" </> "sample-proposal-anchor"
  proposalAnchorDataHash <- execCli' execConfig
    [ "hash", "anchor-data", "--file-binary", proposalAnchorFile
    ]

  -- The file path for the treasury withdrawal action that will be created.
  treasuryWithdrawalActionFp <- H.note $ work </> gov </> "treasury-withdrawal.action"

  -- Find a UTxO from wallet1 to fund the initial transactions.
  txin2 <- findLargestUtxoForPaymentKey epochStateView sbe wallet1

  -- ## 2. Stake Address Registration ##
  -- Before a treasury withdrawal can be proposed, a registered stake address must exist
  -- to receive the funds. This section handles that prerequisite.

  -- {{{ Register stake address
  let stakeCertFp = gov </> "stake.regcert"
      -- Define filepaths for the stake key pair.
      stakeKeys =  KeyPair { verificationKey = File $ gov </> "stake.vkey"
                           , signingKey = File $ gov </> "stake.skey"
                           }
  -- Generate the new stake key pair using 'cardano-cli'.
  cliStakeAddressKeyGen stakeKeys

  -- Query the network for the required key deposit amount.
  keyDeposit <- getKeyDeposit epochStateView ceo
  -- Create the stake address registration certificate.
  createStakeKeyRegistrationCertificate
    tempAbsPath (AnyShelleyBasedEra sbe) (verificationKey stakeKeys) keyDeposit stakeCertFp

  stakeCertTxBodyFp <- H.note $ work </> "stake.registration.txbody"
  stakeCertTxSignedFp <- H.note $ work </> "stake.registration.tx"

  -- Build, sign, and submit a transaction to put the registration certificate on-chain.
  -- This transaction requires two witnesses: the payment key and the new stake key.
  void $ execCli' execConfig
    [ eraName, "transaction", "build"
    , "--change-address", Text.unpack $ paymentKeyInfoAddr wallet1
    , "--tx-in", Text.unpack $ renderTxIn txin2
    , "--tx-out", Text.unpack (paymentKeyInfoAddr wallet0) <> "+" <> show @Int 10_000_000
    , "--certificate-file", stakeCertFp
    , "--witness-override", "2" -- needs witness from payment key and stake key
    , "--out-file", stakeCertTxBodyFp
    ]

  void $ execCli' execConfig
    [ eraName, "transaction", "sign"
    , "--tx-body-file", stakeCertTxBodyFp
    , "--signing-key-file", signingKeyFp $ paymentKeyInfoPair wallet1
    , "--signing-key-file", signingKeyFp stakeKeys
    , "--out-file", stakeCertTxSignedFp
    ]

  void $ execCli' execConfig
    [ eraName, "transaction", "submit"
    , "--tx-file", stakeCertTxSignedFp
    ]
  -- }}}

  -- ## 3. Creating the Treasury Withdrawal Proposal ##
  -- This section proposes the governance action to withdraw funds from the treasury.

  -- {{{ Create treasury withdrawal
  let withdrawalAmount = 3_300_777 :: Integer
  govActionDeposit <- getMinDRepDeposit epochStateView ceo

  let relativeUrl = ["ipfs", proposalAnchorDataIpfsHash]

  txbodyFp <- H.note $ work </> "tx.body"
  txbodySignedFp <- H.note $ work </> "tx.body.signed"

  -- 'serveFilesWhile' starts a temporary, local web server to mimic an IPFS gateway.
  -- This allows 'cardano-cli' to fetch the anchor file via the provided URL.
  serveFilesWhile
    [(relativeUrl, proposalAnchorFile)]
    ( \port -> do
        -- 'cardano-cli governance action create-treasury-withdrawal' is called to create the proposal.
        -- It specifies the amount, the receiving stake key, the deposit return key, and the anchor.
        let execConfig' = addEnvVarsToConfig execConfig [("IPFS_GATEWAY_URI", "http://localhost:" ++ show port ++ "/")]
        void $ execCli' execConfig'
          [ eraName, "governance", "action", "create-treasury-withdrawal"
          , "--testnet"
          , "--anchor-url", "ipfs://" ++ proposalAnchorDataIpfsHash
          , "--anchor-data-hash", proposalAnchorDataHash
          , "--governance-action-deposit", show govActionDeposit
          , "--deposit-return-stake-verification-key-file", verificationKeyFp stakeKeys
          , "--transfer", show withdrawalAmount
          , "--funds-receiving-stake-verification-key-file", verificationKeyFp stakeKeys
          , "--out-file", treasuryWithdrawalActionFp
          ]

        -- wait for one block before using wallet0 again
        _ <- waitForBlocks epochStateView 1

        -- Find a new UTxO to fund the proposal submission transaction.
        txin3 <- findLargestUtxoForPaymentKey epochStateView sbe wallet0

        -- A new transaction is built to place the governance action proposal on the blockchain.
        void $ execCli' execConfig'
          [ eraName, "transaction", "build"
          , "--change-address", Text.unpack $ paymentKeyInfoAddr wallet0
          , "--tx-in", Text.unpack $ renderTxIn txin3
          , "--tx-out", Text.unpack (paymentKeyInfoAddr wallet1) <> "+" <> show @Int 5_000_000
          , "--proposal-file", treasuryWithdrawalActionFp
          , "--out-file", txbodyFp
          ]
    )

  -- Sign and submit the proposal transaction.
  void $ execCli' execConfig
    [ eraName, "transaction", "sign"
    , "--tx-body-file", txbodyFp
    , "--signing-key-file", signingKeyFp $ paymentKeyInfoPair wallet0
    , "--out-file", txbodySignedFp
    ]

  void $ execCli' execConfig
    [ eraName, "transaction", "submit"
    , "--tx-file", txbodySignedFp
    ]
  -- }}}

  -- ## 4. Voting on the Proposal ##
  -- With the proposal on-chain, this section simulates DReps voting to approve it.

  -- Retrieve the transaction ID of the submitted proposal.
  txIdString <- H.noteShowM $ retrieveTransactionId execConfig (File txbodySignedFp)

  -- Scan the blockchain to find the 'GovActionId' of the new proposal. This ID is needed for voting.
  currentEpoch <- getCurrentEpochNo epochStateView
  let terminationEpoch = succ . succ $ currentEpoch
  L.GovActionIx governanceActionIndex <- fmap L.gaidGovActionIx . H.nothingFailM $
    getTreasuryWithdrawalProposal configurationFile socketPath terminationEpoch

  let voteFp :: Int -> FilePath
      voteFp n = work </> gov </> "vote-" <> show n

  -- Simulate three different DReps (1, 2, and 3) all voting 'Yes' on the proposal.
  -- This creates a separate vote file for each DRep.
  H.forConcurrently_ [1..3] $ \n -> do
    execCli' execConfig
      [ eraName, "governance", "vote", "create"
      , "--yes"
      , "--governance-action-tx-id", txIdString
      , "--governance-action-index", show governanceActionIndex
      , "--drep-verification-key-file", verificationKeyFp $ defaultDRepKeyPair n
      , "--out-file", voteFp n
      ]

  txin4 <- findLargestUtxoForPaymentKey epochStateView sbe wallet1

  voteTxFp <- H.note $ work </> gov </> "vote.tx"
  voteTxBodyFp <- H.note $ work </> gov </> "vote.txbody"

  -- {{{ Submit votes
  -- Build a single transaction to submit all three votes to the chain at once.
  -- This transaction requires four witnesses: one for the payment key and one for each DRep.
  void $ execCli' execConfig
    [ eraName, "transaction", "build"
    , "--change-address", Text.unpack $ paymentKeyInfoAddr wallet1
    , "--tx-in", Text.unpack $ renderTxIn txin4
    , "--tx-out", Text.unpack (paymentKeyInfoAddr wallet0) <> "+" <> show @Int 3_000_000
    , "--vote-file", voteFp 1
    , "--vote-file", voteFp 2
    , "--vote-file", voteFp 3
    , "--witness-override", "4" -- 1 for payment key, 3 for drep keys
    , "--out-file", voteTxBodyFp
    ]

  -- Sign the transaction with all four required keys.
  void $ execCli' execConfig
    [ eraName, "transaction", "sign"
    , "--tx-body-file", voteTxBodyFp
    , "--signing-key-file", signingKeyFp $ paymentKeyInfoPair wallet1
    , "--signing-key-file", signingKeyFp $ defaultDRepKeyPair 1
    , "--signing-key-file", signingKeyFp $ defaultDRepKeyPair 2
    , "--signing-key-file", signingKeyFp $ defaultDRepKeyPair 3
    , "--out-file", voteTxFp
    ]

  -- Submit the vote transaction.
  void $ execCli' execConfig
    [ eraName, "transaction", "submit"
    , "--tx-file", voteTxFp
    ]
  -- }}}

  -- ## 5. Verification ##
  -- This is the final and most crucial step. It waits for the governance process to complete
  -- and then checks if the outcome is correct.

  -- Query the ledger state 5 epochs in the future to check for enacted withdrawals.
  -- This delay allows for the governance voting and enactment periods to pass.
  withdrawals <- H.nothingFailM $
    getCurrentEpochNo epochStateView >>=
      getAnyWithdrawals configurationFile socketPath . (`L.addEpochInterval` EpochInterval 5)

  H.noteShow_ withdrawals
  -- The final assertion. It checks that there is exactly one withdrawal and that its value
  -- matches the 'withdrawalAmount' defined at the start of the test.
  (L.unCoin . snd <$> M.toList withdrawals) === [withdrawalAmount]

-- | This helper function scans the ledger state's enactment state ('rsEnactStateL')
-- up to a future epoch. It specifically checks the 'ensWithdrawalsL' field, which
-- contains a map of all enacted treasury withdrawals, returning them for verification.
getAnyWithdrawals
  :: HasCallStack
  => MonadIO m
  => MonadTest m
  => NodeConfigFile In
  -> SocketPath
  -> EpochNo
  -> m (Maybe (Map (Credential Staking) Coin))
getAnyWithdrawals nodeConfigFile socketPath maxEpoch = withFrozenCallStack $ do
  fmap snd . H.leftFailM . evalIO . runExceptT $ foldEpochState nodeConfigFile socketPath FullValidation maxEpoch Nothing
    $ \(AnyNewEpochState actualEra newEpochState _) ->
      caseShelleyToBabbageOrConwayEraOnwards
        (error $ "Expected Conway era onwards, got state in " <> docToString (pretty actualEra))
        (\cEra _ _ -> conwayEraOnwardsConstraints cEra $ do
          let withdrawals = newEpochState
                ^. L.newEpochStateGovStateL
                . L.drepPulsingStateGovStateL
                . to L.extractDRepPulsingState
                . L.rsEnactStateL
                . L.ensWithdrawalsL
          if M.null withdrawals
            then pure ConditionNotMet
            else do
              put $ Just withdrawals
              pure ConditionMet
        ) actualEra

-- | This helper function scans the chain's proposals ('cgsProposalsL') up to a certain
-- epoch ('maxEpoch'). It looks for the first proposal that is a 'TreasuryWithdrawals'
-- action and returns its 'GovActionId'.
getTreasuryWithdrawalProposal
  :: HasCallStack
  => MonadIO m
  => MonadTest m
  => NodeConfigFile In
  -> SocketPath
  -> EpochNo -- ^ The termination epoch: the withdrawal proposal must be found *before* this epoch
  -> m (Maybe L.GovActionId)
getTreasuryWithdrawalProposal nodeConfigFile socketPath maxEpoch = withFrozenCallStack $ do
  fmap snd . H.leftFailM . evalIO . runExceptT $ foldEpochState nodeConfigFile socketPath QuickValidation maxEpoch Nothing
      $ \(AnyNewEpochState actualEra newEpochState _) ->
        caseShelleyToBabbageOrConwayEraOnwards
          (error $ "Expected Conway era onwards, got state in " <> docToString (pretty actualEra))
          (\cEra _ _ -> conwayEraOnwardsConstraints cEra $ do
            let proposals = newEpochState
                    ^. L.newEpochStateGovStateL
                    . L.cgsProposalsL
                govActions = M.toList $ L.proposalsActionsMap proposals
            case map (second L.gasAction) govActions of
              (govActionId, L.TreasuryWithdrawals _ _): _ -> do
                put $ Just govActionId
                pure ConditionMet
              _ ->
                pure ConditionNotMet
          ) actualEra
```

Running this test localy 

```
DISABLE_RETRIES=1 cabal test cardano-testnet-test --test-options '-p "/Treasury Withdrawal/"'
```

Same test running on CI 

https://github.com/IntersectMBO/cardano-node/actions/runs/16196482843/job/45724178228#step:15:184

